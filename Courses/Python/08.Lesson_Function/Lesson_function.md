# Функуии

Есть строенные функции - такие как print, init , str и так далее  
А можно создать функцию.

## Интересные встроенные функции
* **`abs`** - модуль числа
* **`min`** , max - находит минимальное и максимальное число в последовательности
* **`round`** - округляет число
* **`sum`** - сумма эллементов последовательности 
* **`enumerate`** - нумерация последовательности

<details><summary>Примеры:</summary>
<p>

```python
print(abs(-7)) 
```
на выходе будет `7`
```python
numbers = [5,7,8,10,15,-5]
print(min(numbers))
print(max(numbers))
```
на выходе будет `-5  `
на выходе будет `15`
```python
print(round(10.86745 , 2)) 
```
где цифра после запятой это число разрядов округления - на выходе будет `10.87`
```python
print(sum(numbers)) 
```
На выходе будет `40`

```python
winners = [Leo , Max , Kate]

for number , winer in enumerate(winners , 1):
    print(number , winer)
```
где в функии `enumerate` после запятой выбирает точка старта  
на выходе будет   
1 Leo  
2 Max  
3 Kate  

</p>
</details>

## Создание собственной функции
Если нам нужно много раз повторять какой-то эллемент программы - то стоит создать свою функцию

Как указать собственную функцию :
1. def `< name >`():
2. Делаем отсуп TAB пишем что должно быть сделанно
3. Для вызова функции используем `< name >`()
> скобки `()` обязательны. Они используются для вноса переменных

<details><summary>Примеры:</summary>
<p>

```python
def print_Hello_World():
    pritn('Hello Wordl')

print_Hello_World()
```

</p>
</details>

Разделители бывают:
1. Простые - без параметра и возврата
2. С параметром но без возврата
3. С параметром и возвратом

<details><summary>Примеры с параметром:</summary>
<p>

```python
def print_sep(sep):
    pritn(sep * 100)

print_sep('*')
print_sep('-')
```
Выведет сначала много ***, потом много ---

</p>
</details>

<details><summary>Примеры с 2 параметрами:</summary>
<p>

```python
def print_sep(sep,sep_len):
    pritn(sep * sep_len)

print_sep('*',100)
print_sep('-',5)
```
Выведет сначала много ***, потом 5 -

</p>
</details>

### Функция с выводом
Нужно вставить в неё выход - `return` - тогда функция при вызове делает что мы её просим и выводит что-то. Это что-то можно использовать дальше

<details><summary>Примеры с возвратом:</summary>
<p>

```python
def get_sep(sep,sep_len):
    return sep * sep_len
sep = get_sep('*',5)
print(" Hello {} World {}  ".format(sep , sep))
print(get_sep('-',5))
```
Вывод: Hello ----- World -----  
и -----

</p>
</details>

*У параметров функции можно назначать значение по умолчанию, тогда если при выводе функции не будет указан параметр, будет браться параметр по умолчанию.* **Пример:**  
```python
def fun(who, say='Greetings')
```
### Передача одного параметра несколько раз в функцию
1. **`args`** - *передача по порядку* - при создании функции перед параметром ставится *. `кортеж`
```python
def fun(say , *who) , def fun(say , *args)
```
2. **`kwargs`** - *передача по имени* - при создании используется 2* в параметрах. `словарь`
```python
def fun(**say) , def fun(**kwargs)
```
<details><summary>Пример kwargs :</summary>
<p>

```python
def get_person(**kwargs):
    for k , v in kwargs.items():
        print(k,v)

get_person(name = 'Kate' , age = 20 , has_car=True)

```
Вывод будет:
Name Kate
age 20
has_car True

</p>
</details>

## Область видимости
*Вкратце говоря - Переменная внутри функции - останется внутри функции. И название этой переменной можно использовать в другом месте.*  
**Разлечают переменные:**
1. **`Глобальные`** - *видимы везде* 
2. **`Локальные`** - *видимы только в определённой области*  
*Созданная переменная внутри функции или блока будет считаться `локальнай`, а если переменная задана до функции или блока - то она будет считаться `глобальной`.*  
* Локальная переменная не может быть использованна вне функции, в которой она создалась
* Глобальную переменную нельзя просто изменить в функции.  
>Что бы изменить внутри функции глобальную переменную, её нужно указать как глобальную внутри функции **global `< переменная >`**

## Функция как объект
*Сама функция является объектом. Можно переменной присвоить функцию или в переменной просчитать функцию.*  
*Можно прописать несколько функций и в каждой из них использовать другую функцию как параметр - __кароче, можно запутаться__*

<details><summary>Пример функции в функции :</summary>
<p>

```python
def filter(numbers , function):
    result = []
    for number in numbers:
        if function(number):
            result.append(number)
    return result

numbers = [1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 , 15 , ]

def is_even(number):
    return number % 2 == 0

def is_noteven(number):
    return number % 2 != 0

def is_more(number):
    return number > 4

print(filter(numbers , is_even))
print(filter(numbers , is_noteven))
print(filter(numbers , is_more))

```
**Вывод будет:**
[2 , 4 , 6 , 10]
[1 , 3 , 5 , 7 , 15]
[5 , 6 , 7 , 10, 15]

</p>
</details>

### **`lambda`** функиця
*Используется для создания анонимных функций по месту их использования*  
`lambda` входные параметры : результат

*По сути используется когда функция простая и можно записать в одну строчку и мы не хотим давать ей название.*

<details><summary>Пример lambda функции :</summary>
<p>

```python
def filter(numbers , function):
    result = []
    for number in numbers:
        if function(number):
            result.append(number)
    return result

numbers = [1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 , 15 , ]

print(filter(numbers , lambda number: number % 2 == 0))

```
**Вывод будет:**
[2 , 4 , 6 , 10]


</p>
</details>


## Встроенные функции

### `sorted `
* сортировка последовательности
* `sorted`(iterable , key = None , reverse = False). 
    * аргументы: последовательность , ключ для сортировки, порядок
    * Можно не использовать всё после * , тогда будут браться параметры по умолчанию.
* Работае как с числами (*по увыбванию*), так и со строками (*по алфавиту*)
* С кортежем чуть сложнее - можно использовать ключ, но для этого нужна функция

<details><summary>Пример sorted с ключём :</summary>
<p>

```python

cyties = [("Москва" , 10000) , ("Нью-Йорк" , 5000) , ("Магадан" , 100000)]

print(sorted(cyties))

def by_coutn(city)
    return city[1]

print(sorted(cyties , key = by_count))
print(sorted(cyties , key = leambda city: city[1]))

```
**Вывод будет:**
[("Магадан" , 100000),("Москва" , 10000),("Нью-Йорк" , 5000)]
[("Нью-Йорк" , 5000),("Москва" , 10000),("Магадан" , 100000)]
[("Нью-Йорк" , 5000),("Москва" , 10000),("Магадан" , 100000)]

</p>
</details>

### `filter `
* Фильтрация последосвательности
* fliter(function , iterable)
    * Аргументы - функция фильтрации, последовательность 

<details><summary>Пример filred :</summary>
<p>

```python

numbers = (1,2,3,4,5,6,7,8,9,10)

def is_even(number):
    return number % 2 == 0

print(list(filter(is_even , numbers)))
print(list(filter(lambda number: number % 2 == 0 , numbers)))

```
**Вывод будет:**
[2,4,6,8,10]

</p>
</details>

### `map `
* применение функции к каждому эллементу последовательности
* map(funct , iterable , ..)
    * аргументы : функция , последовательность